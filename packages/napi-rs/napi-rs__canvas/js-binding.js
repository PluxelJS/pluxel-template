
// Auto-generated by pluxel-plugin-napi-rs
//
// Universal CJS js-binding for napi-rs style packages.
//
// Reads from ./package.json:
//   - napi.binaryName
//   - optionalDependencies
//
// Stores runtime binaries at:
//   <process.cwd()>/napi-rs/<binaryName>/*.node
//
// Env:
//   - NAPI_RS_DISABLE_RUNTIME_DOWNLOAD=1
//   - NAPI_RS_REGISTRY / NPM_REGISTRY

const fs = require("node:fs");
const path = require("node:path");
const { spawnSync } = require("node:child_process");
const pkgRoot = path.resolve(__dirname, "..");

const corePkg = require("./package.json");
const binaryName = corePkg && corePkg.napi && corePkg.napi.binaryName;

if (!binaryName) {
  throw new Error("Missing napi.binaryName in core package.json");
}

const optional = corePkg.optionalDependencies || {};
const optionalNames = Object.keys(optional);

const NAPI_ROOT = path.join(process.cwd(), "napi-rs");
const BIN_DIR = path.join(NAPI_ROOT, binaryName);

function detectMusl() {
  if (process.platform !== "linux") return false;
  try {
    const report = process.report && process.report.getReport && process.report.getReport();
    return !(report && report.header && report.header.glibcVersionRuntime);
  } catch (_) {
    return false;
  }
}

/**
 * Strict white-list selection:
 *  - optionalDependencies is the upstream whitelist
 *  - filter by platform + arch only
 *  - 0 candidates -> throw
 *  - linux: prefer musl/gnu if multiple candidates exist
 */
function pickBinaryPackageName() {
  const p = process.platform;
  const a = process.arch;

  const candidates = optionalNames.filter(
    (n) => n.indexOf("-" + p + "-") !== -1 && n.indexOf("-" + a + "-") !== -1,
  );

  if (candidates.length === 0) {
    throw new Error(
      "No prebuilt binary listed for " + p + "/" + a +
      ". Available optionalDependencies: " + optionalNames.join(", ")
    );
  }

  if (candidates.length === 1) return candidates[0];

  if (p === "linux") {
    const musl = detectMusl();
    const preferred = candidates.find((n) => n.indexOf(musl ? "musl" : "gnu") !== -1);
    if (preferred) return preferred;
  }

  return candidates.sort()[0];
}

function listLocalNodes(dir) {
  try {
    return fs.readdirSync(dir).filter(function (f) {
      return f.endsWith(".node");
    }).sort();
  } catch (_) {
    return [];
  }
}

function pickLocalNodeFile() {
  const nodes = listLocalNodes(BIN_DIR);
  if (nodes.length === 0) return null;
  return nodes[0];
}

function findBundledNodeFile() {
  try {
    const files = fs.readdirSync(pkgRoot).filter(function (f) {
      return f.endsWith(".node");
    }).sort();
    if (files.length === 0) return null;
    return path.join(pkgRoot, files[0]);
  } catch (_) {
    return null;
  }
}

/**
 * Sync download/extract:
 *  - parent process keeps require synchronous
 *  - child process runs ESM + modern-tar for async fetch + streaming extraction
 *  - child resolves dist.tarball from registry metadata (no URL guessing)
 */
function ensureBinaryDownloaded(depName, depVersion) {
  fs.mkdirSync(BIN_DIR, { recursive: true });

  const esmLines = [
    'import fs from "node:fs";',
    'import path from "node:path";',
    'import crypto from "node:crypto";',
    'import { createGzipDecoder, unpackTar } from "modern-tar";',
    '',
    'const depName = process.env.NAPI_RS_DEP_NAME;',
    'const depVersion = process.env.NAPI_RS_DEP_VERSION;',
    'const binaryName = process.env.NAPI_RS_BINARY_NAME;',
    'const outRoot = process.env.NAPI_RS_OUT_ROOT;',
    'const registry = process.env.NAPI_RS_REGISTRY || process.env.NPM_REGISTRY || "https://registry.npmjs.org";',
    '',
    'if (!depName || !depVersion || !binaryName || !outRoot) {',
    '  throw new Error("Missing env for runtime downloader");',
    '}',
    '',
    'function toHashPlan(integrity, shasum) {',
    '  if (integrity) {',
    '    const parts = integrity.split("-");',
    '    const algo = parts[0] || "sha512";',
    '    const expected = parts[1] || "";',
    '    return { algo, expected, format: "base64" };',
    '  }',
    '  if (shasum) {',
    '    return { algo: "sha1", expected: String(shasum).toLowerCase(), format: "hex" };',
    '  }',
    '  return null;',
    '}',
    '',
    'async function verifyIntegrity(body, integrity, shasum) {',
    '  const plan = toHashPlan(integrity, shasum);',
    '  if (!plan) return;',
    '  const hash = crypto.createHash(plan.algo);',
    '  const reader = body.getReader();',
    '  while (true) {',
    '    const { done, value } = await reader.read();',
    '    if (done) break;',
    '    if (value) hash.update(value);',
    '  }',
    '  const digest = hash.digest(plan.format);',
    '  const ok = plan.format === "hex"',
    '    ? digest.toLowerCase() === plan.expected',
    '    : digest === plan.expected;',
    '  if (!ok) {',
    '    throw new Error("Integrity check failed for " + depName + "@" + depVersion);',
    '  }',
    '}',
    '',
    'const metaUrl = registry + "/" + encodeURIComponent(depName);',
    'const metaRes = await fetch(metaUrl);',
    'if (!metaRes.ok) {',
    '  throw new Error("Failed to fetch metadata: " + metaUrl + " " + metaRes.status);',
    '}',
    'const meta = await metaRes.json();',
    'const verMeta = meta.versions && meta.versions[depVersion];',
    'const tarballUrl = verMeta && verMeta.dist && verMeta.dist.tarball;',
    'const integrity = verMeta && verMeta.dist && verMeta.dist.integrity;',
    'const shasum = verMeta && verMeta.dist && verMeta.dist.shasum;',
    'if (!tarballUrl) {',
    '  throw new Error("No dist.tarball for " + depName + "@" + depVersion);',
    '}',
    '',
    'const res = await fetch(tarballUrl);',
    'if (!res.ok || !res.body) {',
    '  throw new Error("Failed to fetch binary tarball: " + tarballUrl + " " + res.status);',
    '}',
    '',
    'const outDir = path.join(outRoot, binaryName);',
    'fs.mkdirSync(outDir, { recursive: true });',
    'const cleanupNodes = () => {',
    '  try {',
    '    for (const f of fs.readdirSync(outDir)) {',
    '      if (f.endsWith(".node")) {',
    '        fs.rmSync(path.join(outDir, f), { force: true });',
    '      }',
    '    }',
    '  } catch (_) {}',
    '};',
    'cleanupNodes();',
    '',
    'let extractBody = res.body;',
    'const needsIntegrity = integrity || shasum;',
    'if (needsIntegrity && res.body) {',
    '  if (res.body.tee) {',
    '    const [hashStream, extractStream] = res.body.tee();',
    '    await verifyIntegrity(hashStream, integrity, shasum);',
    '    extractBody = extractStream;',
    '  } else {',
    '    const chunks = [];',
    '    const reader = res.body.getReader();',
    '    while (true) {',
    '      const { done, value } = await reader.read();',
    '      if (done) break;',
    '      if (value) chunks.push(Buffer.from(value));',
    '    }',
    '    const full = Buffer.concat(chunks);',
    '    await verifyIntegrity(new Blob([full]).stream(), integrity, shasum);',
    '    extractBody = new Blob([full]).stream();',
    '  }',
    '}',
    '',
    'const entries = await unpackTar(',
    '  extractBody.pipeThrough(createGzipDecoder()),',
    ');',
    '',
    'let wroteAny = false;',
    'for (const entry of entries) {',
    '  let name = entry.header.name || "";',
    '  if (name.startsWith("package/")) name = name.slice("package/".length);',
    '  if (!name || name.endsWith("/")) {',
    '    continue;',
    '  }',
    '  const base = path.basename(name);',
    '  if (!base.endsWith(".node")) {',
    '    continue;',
    '  }',
    '  const data = entry && entry.data;',
    '  if (!data || data.length === 0) {',
    '    continue;',
    '  }',
    '  const dest = path.join(outDir, base);',
    '  fs.writeFileSync(dest, data);',
    '  wroteAny = true;',
    '}',
    '',
    'if (!wroteAny) {',
    '  cleanupNodes();',
    '  throw new Error("No .node extracted from " + depName + "@" + depVersion);',
    '}',
  ];

  const esm = esmLines.join("\n");

  const child = spawnSync(
    process.execPath,
    ["--input-type=module", "-e", esm],
    {
      stdio: "inherit",
      // Run from package root so the bundled modern-tar dependency is resolvable
      cwd: pkgRoot,
      env: {
        ...process.env,
        NAPI_RS_DEP_NAME: depName,
        NAPI_RS_DEP_VERSION: depVersion,
        NAPI_RS_BINARY_NAME: binaryName,
        NAPI_RS_OUT_ROOT: NAPI_ROOT,
      },
    },
  );

  if (child.status !== 0) {
    throw new Error("Runtime download failed for " + depName + "@" + depVersion);
  }
}

function loadNative() {
  const bundled = findBundledNodeFile();
  if (bundled) {
    return require(bundled);
  }

  let local = pickLocalNodeFile();
  if (local) {
    return require(path.join(BIN_DIR, local));
  }

  const depName = pickBinaryPackageName();
  const depVersion = optional[depName];

  if (!depVersion) {
    throw new Error("Missing version for optional dependency: " + depName);
  }

  if (process.env.NAPI_RS_DISABLE_RUNTIME_DOWNLOAD === "1") {
    throw new Error(
      "Runtime download disabled and no local .node found at: " + BIN_DIR,
    );
  }

  ensureBinaryDownloaded(depName, depVersion);

  local = pickLocalNodeFile();
  if (!local) {
    throw new Error("No .node found after download at: " + BIN_DIR);
  }

  return require(path.join(BIN_DIR, local));
}

module.exports = loadNative();
