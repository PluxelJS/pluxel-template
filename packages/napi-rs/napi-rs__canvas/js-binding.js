
// Auto-generated by pluxel-plugin-napi-rs
//
// Universal CJS js-binding for napi-rs style packages.
//
// Reads from ./package.json:
//   - napi.binaryName
//   - optionalDependencies
//
// Stores runtime binaries at:
//   <process.cwd()>/napi-rs/<binaryName>/*.node
//
// Env:
//   - NAPI_RS_DISABLE_RUNTIME_DOWNLOAD=1
//   - NAPI_RS_REGISTRY / NPM_REGISTRY

const fs = require("node:fs");
const path = require("node:path");
const { spawnSync } = require("node:child_process");
const pkgRoot = path.resolve(__dirname, "..");

const corePkg = require("./package.json");
const binaryName = corePkg && corePkg.napi && corePkg.napi.binaryName;

if (!binaryName) {
  throw new Error("Missing napi.binaryName in core package.json");
}

const optional = corePkg.optionalDependencies || {};
const optionalNames = Object.keys(optional);

const NAPI_ROOT = path.join(process.cwd(), "napi-rs");
const BIN_DIR = path.join(NAPI_ROOT, binaryName);

function detectMusl() {
  if (process.platform !== "linux") return false;
  try {
    const report = process.report && process.report.getReport && process.report.getReport();
    return !(report && report.header && report.header.glibcVersionRuntime);
  } catch (_) {
    return false;
  }
}

/**
 * Strict white-list selection:
 *  - optionalDependencies is the upstream whitelist
 *  - filter by platform + arch only
 *  - 0 candidates -> throw
 *  - linux: prefer musl/gnu if multiple candidates exist
 */
function pickBinaryPackageName() {
  const p = process.platform;
  const a = process.arch;

  const candidates = optionalNames.filter(
    (n) => n.indexOf("-" + p + "-") !== -1 && n.indexOf("-" + a + "-") !== -1,
  );

  if (candidates.length === 0) {
    throw new Error(
      "No prebuilt binary listed for " + p + "/" + a +
      ". Available optionalDependencies: " + optionalNames.join(", ")
    );
  }

  if (candidates.length === 1) return candidates[0];

  if (p === "linux") {
    const musl = detectMusl();
    const preferred = candidates.find((n) => n.indexOf(musl ? "musl" : "gnu") !== -1);
    if (preferred) return preferred;
  }

  return candidates.sort()[0];
}

function listLocalNodes() {
  try {
    return fs.readdirSync(BIN_DIR).filter(function (f) {
      return f.endsWith(".node");
    }).sort();
  } catch (_) {
    return [];
  }
}

function pickLocalNodeFile() {
  const nodes = listLocalNodes();
  if (nodes.length === 0) return null;
  return nodes[0];
}

/**
 * Sync download/extract:
 *  - parent process keeps require synchronous
 *  - child process runs ESM + modern-tar for async fetch + streaming extraction
 *  - child resolves dist.tarball from registry metadata (no URL guessing)
 */
function ensureBinaryDownloaded(depName, depVersion) {
  fs.mkdirSync(BIN_DIR, { recursive: true });

  const esmLines = [
    'import fs from "node:fs";',
    'import path from "node:path";',
    'import { createGzipDecoder, createTarDecoder } from "modern-tar";',
    '',
    'const depName = process.env.NAPI_RS_DEP_NAME;',
    'const depVersion = process.env.NAPI_RS_DEP_VERSION;',
    'const binaryName = process.env.NAPI_RS_BINARY_NAME;',
    'const outRoot = process.env.NAPI_RS_OUT_ROOT;',
    'const registry = process.env.NAPI_RS_REGISTRY || process.env.NPM_REGISTRY || "https://registry.npmjs.org";',
    '',
    'if (!depName || !depVersion || !binaryName || !outRoot) {',
    '  throw new Error("Missing env for runtime downloader");',
    '}',
    '',
    'const metaUrl = registry + "/" + encodeURIComponent(depName);',
    'const metaRes = await fetch(metaUrl);',
    'if (!metaRes.ok) {',
    '  throw new Error("Failed to fetch metadata: " + metaUrl + " " + metaRes.status);',
    '}',
    'const meta = await metaRes.json();',
    'const verMeta = meta.versions && meta.versions[depVersion];',
    'const tarballUrl = verMeta && verMeta.dist && verMeta.dist.tarball;',
    'if (!tarballUrl) {',
    '  throw new Error("No dist.tarball for " + depName + "@" + depVersion);',
    '}',
    '',
    'const outDir = path.join(outRoot, binaryName);',
    'fs.mkdirSync(outDir, { recursive: true });',
    '',
    'const res = await fetch(tarballUrl);',
    'if (!res.ok || !res.body) {',
    '  throw new Error("Failed to fetch binary tarball: " + tarballUrl + " " + res.status);',
    '}',
    '',
    'const entries = res.body',
    '  .pipeThrough(createGzipDecoder())',
    '  .pipeThrough(createTarDecoder());',
    '',
    'async function writeWebStream(destPath, body) {',
    '  const reader = body.getReader();',
    '  const writer = fs.createWriteStream(destPath);',
    '  try {',
    '    while (true) {',
    '      const result = await reader.read();',
    '      if (result.done) break;',
    '      const value = result.value;',
    '      if (!value) continue;',
    '      if (!writer.write(Buffer.from(value))) {',
    '        await new Promise((r) => writer.once("drain", r));',
    '      }',
    '    }',
    '  } finally {',
    '    await new Promise((resolve, reject) => {',
    '      writer.on("finish", resolve);',
    '      writer.on("error", reject);',
    '      writer.end();',
    '    });',
    '  }',
    '}',
    '',
    'let wroteAny = false;',
    'for await (const entry of entries) {',
    '  let name = entry.header.name || "";',
    '  if (name.startsWith("package/")) name = name.slice("package/".length);',
    '  if (!name || name.endsWith("/")) {',
    '    if (entry.body && entry.body.cancel) {',
    '      try { await entry.body.cancel(); } catch (_) {}',
    '    }',
    '    continue;',
    '  }',
    '  const base = path.basename(name);',
    '  if (!base.endsWith(".node")) {',
    '    if (entry.body && entry.body.cancel) {',
    '      try { await entry.body.cancel(); } catch (_) {}',
    '    }',
    '    continue;',
    '  }',
    '  const dest = path.join(outDir, base);',
    '  await writeWebStream(dest, entry.body);',
    '  wroteAny = true;',
    '}',
    '',
    'if (!wroteAny) {',
    '  throw new Error("No .node extracted from " + depName + "@" + depVersion);',
    '}',
  ];

  const esm = esmLines.join("\n");

  const child = spawnSync(
    process.execPath,
    ["--input-type=module", "-e", esm],
    {
      stdio: "inherit",
      // Run from package root so the bundled modern-tar dependency is resolvable
      cwd: pkgRoot,
      env: {
        ...process.env,
        NAPI_RS_DEP_NAME: depName,
        NAPI_RS_DEP_VERSION: depVersion,
        NAPI_RS_BINARY_NAME: binaryName,
        NAPI_RS_OUT_ROOT: NAPI_ROOT,
      },
    },
  );

  if (child.status !== 0) {
    throw new Error("Runtime download failed for " + depName + "@" + depVersion);
  }
}

function loadNative() {
  const depName = pickBinaryPackageName();
  const depVersion = optional[depName];

  if (!depVersion) {
    throw new Error("Missing version for optional dependency: " + depName);
  }

  // 1) prefer local
  let local = pickLocalNodeFile();
  if (local) {
    return require(path.join(BIN_DIR, local));
  }

  // 2) fallback: download
  if (process.env.NAPI_RS_DISABLE_RUNTIME_DOWNLOAD === "1") {
    throw new Error(
      "Runtime download disabled and no local .node found at: " + BIN_DIR,
    );
  }

  ensureBinaryDownloaded(depName, depVersion);

  local = pickLocalNodeFile();
  if (!local) {
    throw new Error("No .node found after download at: " + BIN_DIR);
  }

  return require(path.join(BIN_DIR, local));
}

module.exports = loadNative();
